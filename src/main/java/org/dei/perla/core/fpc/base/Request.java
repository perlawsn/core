package org.dei.perla.core.fpc.base;

import org.dei.perla.core.sample.Attribute;
import org.dei.perla.core.sample.Sample;
import org.dei.perla.core.sample.SamplePipeline;
import org.dei.perla.core.sample.SamplePipeline.PipelineBuilder;

import java.time.Instant;
import java.util.*;

/**
 * {@code Request} objects are a utility objects that implement the
 * functionalities required to determine, given a list of attributes, which
 * of these are associated to values that can be served statically by an
 * {@link FPC}.
 *
 * @author Guido Rota 02/07/15.
 */
public final class Request {

    private final List<Attribute> request;

    private final boolean hasTimestamp;
    private final int timestampIndex;
    private final List<Attribute> staticReq = new ArrayList<>();
    private final Map<Attribute, Object> staticValues = new HashMap<>();
    private final Object[] staticSample;
    private final List<Attribute> dynamicReq = new ArrayList<>();

    /**
     * Creates a new {@code Request} object
     *
     * @param request {@link Attribute}s requested by the user
     * @param staticFpc {@link Attribute}s that can be served statically by
     *                                   an {@link FPC}
     */
    public Request(List<Attribute> request,
            Map<Attribute, Object> staticFpc) {
        this.request = Collections.unmodifiableList(request);

        int tsIdx = -1;
        int i = 0;
        for (Attribute a : request) {
            if (a == Attribute.TIMESTAMP) {
                // Skip timestamp attribute, it's implicit in every request,
                // and it's generated by the SamplePipeline when needed
                tsIdx = i;
            } else if (staticFpc.containsKey(a)) {
                staticReq.add(a);
                staticValues.put(a, staticFpc.get(a));
            } else {
                dynamicReq.add(a);
            }
            i++;
        }

        if (isStatic()) {
            if (tsIdx == -1) {
                staticReq.add(Attribute.TIMESTAMP);
                tsIdx = staticReq.size() - 1;
            }
            staticSample = precomputeStaticSample();
        } else {
            staticSample = null;
        }

        hasTimestamp = tsIdx != -1;
        timestampIndex = tsIdx;
    }

    private Object[] precomputeStaticSample() {
        Object[] o = new Object[staticReq.size()];
        int i = 0;
        for (Attribute a : staticReq) {
            if (a == Attribute.TIMESTAMP) {
                o[i] = Instant.now();
            } else {
                o[i] = staticValues.get(a);
            }
            i++;
        }
        return o;
    }

    public List<Attribute> getRequest() {
        return request;
    }

    /**
     * Indicates if all the {@link Atttibute}s requested by the user can be
     * served statically
     *
     * @return true if all user-requested {@link Attribute}s can be served
     * statically, false otherwise
     */
    public boolean isStatic() {
        return dynamicReq.isEmpty();
    }

    /**
     * Returns a list of the user requested {@link Attribute}s that can be
     * served statically
     *
     * @return list of {@link Attribute}s that can be served statically
     */
    public List<Attribute> getStatic() {
        return staticReq;
    }

    /**
     * Returns a list of the user requested {@link Attribute}s whose value
     * must be sampled from the device connected to the {@link FPC}
     *
     * @return list of dynamic {@link Attribute}s requested by the user
     */
    public List<Attribute> getDynamic() {
        return dynamicReq;
    }

    /**
     * Creates a new {@link Sample} using the static {@link Fpc} {@link
     * Attributes}. This method is employed to create a new sample when the
     * user request contains only static {@link Attribute}s.
     *
     * @return new {@link Sample} instance
     * @throws RuntimeException if the {@code Request} is not completely static
     */
    public Sample newStaticSample() throws RuntimeException {
        if (!isStatic()) {
            throw new RuntimeException("Cannot create static sample from " +
                    "non-static request");
        }

        Object[] values = Arrays.copyOf(staticSample, staticSample.length);
        values[timestampIndex] = Instant.now();
        return new Sample(staticReq, values);
    }

    /**
     * Creates a {@link SamplePipeline} that can be used to process the data
     * coming from the underlying {@link Operaiton}. This method will take care
     * to decorate the raw samples coming from the {@link Operaiton} with
     * a timestamp (if needed) and static attributes. Moreover, it will
     * instruct the pipeline to reorder the attribute order to
     *
     * @param opAtts {@link Attribute}s generated by the {@link Operation}
     * @return new {@link SamplePipeline} tailored around the {@link
     * Operation} that generates the raw data and the user's request
     * @throws IllegalStateException when the user's request only contains
     * static {@link Attribute}s
     */
    public SamplePipeline createPipeline(List<Attribute> opAtts)
            throws IllegalStateException {
        if (isStatic()) {
            throw new IllegalStateException(
                    "Cannot create pipeline, request is static");
        }

        PipelineBuilder build = SamplePipeline.newBuilder(opAtts);
        if (!hasTimestamp) {
            build.addTimestamp();
        }
        if (staticReq.size() != 0) {
            build.addStatic(staticValues);
        }
        build.reorder(request);
        return build.create();
    }

}
