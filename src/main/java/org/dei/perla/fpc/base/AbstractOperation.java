package org.dei.perla.fpc.base;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Consumer;
import java.util.function.Supplier;

import org.apache.log4j.Logger;
import org.dei.perla.fpc.Attribute;
import org.dei.perla.fpc.FpcException;
import org.dei.perla.fpc.Task;
import org.dei.perla.fpc.TaskHandler;
import org.dei.perla.utils.Conditions;
import org.dei.perla.utils.StopHandler;

/**
 * <p>
 * An abstract implementation of the {@link AbstractOperation} interface. This
 * class provides a common implementation of several housekeeping methods needed
 * by all {@link Operation} classes.
 * </p>
 * 
 * <p>
 * This implementation keeps a list of all tasks scheduled by the operation.
 * Imlementing classes are responsible for managing the addition or removal of
 * {@link Task}s using the {@code add()} and {@code remove()} methods.
 * </p>
 * 
 * @author Guido Rota (2014)
 *
 */
public abstract class AbstractOperation<T extends AbstractTask> implements
		Operation {

	protected final Logger log;

	private final String id;
	private final Collection<Attribute> attributes;

	// State
	private final Lock lock = new ReentrantLock();
	private volatile boolean schedulable;

	// Unsynchronized acces to the taskList when reading. Reads on the
	// taskList will greatly outnumber the writes, since this list is traversed
	// every time a record is produced by the remote device.
	private volatile List<T> taskList = new CopyOnWriteArrayList<>();

	/**
	 * {@code AbstractOperation} constructor.
	 * 
	 * @param id
	 *            Operation identifier
	 * @param attributes
	 *            Collection of {@link Attribute}s generated by the
	 *            {@link Operation}
	 */
	public AbstractOperation(String id, Collection<Attribute> attributes) {
		this.id = id;
		this.attributes = attributes;
		schedulable = true;
		this.log = Logger.getLogger(this.getClass().getSimpleName() + "_" + id);
	}

	@Override
	public final String getId() {
		return id;
	}

	@Override
	public final Collection<Attribute> getAttributes() {
		return attributes;
	}

	@Override
	public final boolean isSchedulable() {
		return schedulable;
	}

	@Override
	public final AbstractTask schedule(Map<String, Object> parameterMap,
			TaskHandler handler, RecordPipeline pipeline)
			throws IllegalArgumentException, IllegalStateException {
		Conditions.checkNotNull(handler, "handler");
		if (!schedulable) {
			throw new IllegalStateException("Operation '" + id
					+ "' is not schedulable");
		}

		lock.lock();
		try {

			// Wrapping the invocation inside a lockensures that the scheduling
			// operations are run in mutual exclusion with all other methods
			// that may modify the internal task list or the operating status of
			// this operation
			return doSchedule(parameterMap, handler, pipeline);

		} finally {
			lock.unlock();
		}
	}

	/**
	 * <p>
	 * Performs the actual scheduling of a new {@link Task}.
	 * </p>
	 * 
	 * <p>
	 * This method is executed in mutual exclusion with all other operation that
	 * may change the task list content or the internal state of this
	 * {@link AbstractOperation}.
	 * </p>
	 * 
	 * @param parameterMap
	 *            Parameters to be passed
	 * @param handler
	 *            {@link TaskHandler} object used to asynchronously collect the
	 *            {@code Operation} output
	 * @return {@link Task} object for controlling the {@code Operation}
	 *         execution
	 * @throws IllegalArgumentException
	 *             When the parameters required to run this operation are
	 *             notfound in the parameterMap
	 * @throws IllegalStateException
	 *             If the {@code schedule} method is invoked when the
	 *             {@code Operation} is not running
	 */
	protected abstract T doSchedule(Map<String, Object> parameterMap,
			TaskHandler handler, RecordPipeline pipeline)
			throws IllegalArgumentException;

	@Override
	public final void stop(StopHandler<Operation> handler) {
		if (!schedulable) {
			return;
		}

		lock.lock();
		try {

			taskList.forEach(t -> t.operationStopped());
			taskList.clear();
			doStop(handler);
			schedulable = false;

		} finally {
			lock.unlock();
		}
	}

	/**
	 * Method invoked to stop the {@code AbstractOperation}. It can be
	 * overridden if a custom stop behaviour is required.
	 */
	protected abstract void doStop();

	/**
	 * <p>
	 * Method invoked to stop the {@code AbstractOperation}. It can be
	 * overridden if a custom stop behaviour is required.
	 * </p>
	 * 
	 * <p>
	 * This version of the {@code doStop()} method takes a {@link StopHandler}
	 * argument to asynchronously notify the caller about the correct shutdown
	 * of the {@link Operation}. All implementations of the
	 * {@code AbstractOperation} class must invoke the
	 * {@code StopHandler.hasStopped()} method when the operation has been
	 * properly stopped. Failure to due so may lead other {@code Fpc} components
	 * to fail at shutdown.
	 * </p>
	 *
	 * @param handler
	 *            StopHandler invoked when the operation is corectly terminated
	 */
	protected abstract void doStop(StopHandler<Operation> handler);

	/**
	 * <p>
	 * Adds an {@link AbstractTask} to the list of tasks scheduled by this
	 * {@code AbstractOperation}.
	 * </p>
	 * 
	 * <p>
	 * This method is executed in mutual exclusion with all other operation that
	 * may change the task list content or the internal state of this
	 * {@link AbstractOperation}.
	 * </p>
	 * 
	 * @param task
	 *            {@link AbstractTask} to be added
	 */
	protected final void add(T task) {
		lock.lock();
		try {
			taskList.add(task);
		} finally {
			lock.unlock();
		}
	}

	/**
	 * <p>
	 * Removes an {@link AbstractTask} from the list of task scheduled by this
	 * {@code AbstractOperation}.
	 * </p>
	 * 
	 * <p>
	 * This method is executed in mutual exclusion with all other operation that
	 * may change the task list content or the internal state of this
	 * {@link AbstractOperation}.
	 * </p>
	 * 
	 * @param task
	 *            {@link AbstractTask} to be removed
	 */
	protected final void remove(AbstractTask task) {
		lock.lock();
		try {

			if (!taskList.contains(task)) {
				return;
			}
			taskList.remove(task);

			if (taskList.isEmpty()) {
				doStop();
				return;
			}

			postRemove(Collections.unmodifiableList(taskList));

		} finally {
			lock.unlock();
		}
	}

	/**
	 * <p>
	 * Method invoked after a {@link Task} is removed from the internal task
	 * list. It is intended to be overridden by concrete
	 * {@code AbstractOperation} implementations.
	 * </p>
	 * 
	 * <p>
	 * This method will not be invoked when the task list is empty. In this
	 * case, the {@code doStop()} method will be called instead.
	 * </p>
	 * 
	 * <p>
	 * This method is executed in mutual exclusion with all other operation that
	 * may change the task list content or the internal state of this
	 * {@link AbstractOperation}.
	 * </p>
	 * 
	 * @param taskList
	 *            List of remaining {@link Task}s
	 */
	protected void postRemove(List<T> taskList) {
	}

	/**
	 * <p>
	 * Stops all active {@link Task}s and signal the cause of the error that
	 * prompted this action.
	 * </p>
	 * 
	 * <p>
	 * This method is executed in mutual exclusion with all other operation that
	 * may change the task list content or the internal state of this
	 * {@link AbstractOperation}.
	 * </p>
	 * 
	 * @param message
	 *            Error message
	 * @param cause
	 *            Cause of the unrecoverable error
	 */
	protected final void unrecoverableError(String message, Throwable cause) {
		lock.lock();
		try {
			
			log.error("Unexpected error, stopping operation", cause);
			FpcException e = new FpcException(message, cause);
			taskList.forEach(t -> t.operationError(e));
			taskList.clear();
			doStop();

		} finally {
			lock.unlock();
		}
	}

	// ////////////////
	// Utility methods
	// ////////////////

	/**
	 * Returns the number of {@link Task}s currently scheduled on this
	 * {@code AbstractOperation}
	 * 
	 * @return Number of scheduled {@link Task}s
	 */
	protected final int taskCount() {
		return taskList.size();
	}

	/**
	 * <p>
	 * Performs the function passed as parameter in mutual exclusion with all
	 * other methods that may change the internal task list or that may modify
	 * the {@code Operation} state.
	 * </p>
	 * 
	 * @param operation
	 *            Operation to perform
	 */
	protected final void runUnderLock(Runnable operation) {
		lock.lock();
		try {
			operation.run();
		} finally {
			lock.unlock();
		}
	}

	/**
	 * <p>
	 * Performs the function passed as parameter in mutual exclusion with all
	 * other methods that may change the internal task list or that may modify
	 * the {@code Operation} state.
	 * </p>
	 * 
	 * @param operation
	 *            Operation to perform
	 */
	protected final <E> E runUnderLock(Supplier<E> operation) {
		lock.lock();
		try {
			return operation.get();
		} finally {
			lock.unlock();
		}
	}

	/**
	 * Performs the operation passed as parameter for all registered
	 * {@link PeriodicTask}s
	 * 
	 * @param operation
	 *            Operation to execute
	 */
	public final void forEachTask(Consumer<T> operation) {
		taskList.forEach(operation);
	}

}
